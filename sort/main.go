package main

import "fmt"

// 排序有很多种方法，根据时间负载度可氛围 O(n^2) 和 O(nlog(n)) 两个大类
// O(nlog(n)) 为重点包括，快速排序，
// O(n) 包括 冒泡排序，插排

// 冒泡排序
// 关于边界问题的一点认知：做算法题的时候，
// 你知道某个数的循环取值应该是末尾下标到 i 下标之间取
// 但循环边界怎么定义，假设这个数的起始取值下标是 j
// 首先 j 的取值肯定是	i
// 其次每次一定是 j 加 一
// 但边界值怎么定义，第一反应不就是小于len(x) - 1 吗
// 问题来了是小于还是小于等于，如果j 需要取 len(x) - 1
// 就是尾下标的值是 一定要加等号的 , 我们常见的写法是 j < len(x)
// 这并不好理解，最好的理解方式是 j:=i; j<=len(x) - 1;j++
// 在比如这道冒泡的的题目，这个题其实就是从起始位开始相邻元素比较大小，
// 每次沉底一个最大的数，这个数就不用比了
// 首先是每次，这个要进行多少次相邻元素遍历交换，按照每次沉底一个数不管，
// 到最后一次交换一定是沉底了len(x) - 1 个数， 如果从0 开始应该是i:=0 i<= len(x)-2 ;i++
// 更好理解的是 i:=1;i<=len(x)-1;i++ 每次沉底一个数到沉底len(x)-1个数为最后一次
// 每次相邻元素交换多少次，每次的沉底数是不做交换的，
// 所以按照理解应该是len(x)-i-1 最后减去1意思是最后一次交换一定是倒数第二个数和倒数第一个数的比较
// 这是最后一次，所以倒数第一个数是不需要独立取遍历交换
// 这就涉及到取不取这个沉底数了，这道题是不取所以是len(x) - i 如果要取那一定是len(x) -i + 1
// 换成下标就是从0 开始到 尾下标减去i len(x)-1-i
func maoPao(nums []int) []int {
	for i := 0; i <= len(nums)-2; i++ {
		for j := 0; j <= len(nums)-2-i; j++ {
			if nums[j] > nums[j+1] {
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
	return nums
}

func main() {
	fmt.Println("冒泡：", maoPao([]int{4, 6, 1, 7, 8, 9, 12, 89, 90, 11, 0}))
}
